---
name: Math
route: /math
---

# Math

---

## `bin()`

```tsx
const bin: (value: boolean) => 0 | 1
```

Convert a boolean value into a number.
This can be useful in reanimated since 0 and 1 are used for conditional statements.

---

## `inc()`

```tsx
const inc: (value: Animated.Value<number>) => Animated.Node<number>
```

Increment value by one.

---

## `dec()`

```tsx
const dec: (value: Animated.Value<number>) => Animated.Node<number>;
```

Decrement value by one.

---

## `toRad()`

```tsx
const toRad: (deg: Animated.Adaptable<number>) => Animated.Node<number>;
```

Transforms an angle from degrees to radians.

---

## `toDeg()`

```tsx
const toDeg: (rad: Animated.Adaptable<number>) => Animated.Node<number>;
```

Transforms an angle from radians to degrees.

---

## `min()`

```tsx
const min: (...args: Animated.Adaptable<number>[]) => Animated.Adaptable<number>;
```

Takes one or more nodes as input and returns the minimum of all the node's values.
This is equivalent to `Animated.min` but with support for more than two parameters.


---

## `max()`

```tsx
const max: (...args: Animated.Adaptable<number>[]) => Animated.Adaptable<number>;
```

Takes one or more nodes as input and returns the maximum of all the node's values.
This is equivalent to `Animated.min` but with support for more than two parameters.

---

## `clamp()`

```tsx
const clamp: (value: Animated.Adaptable<number>, lowerBound: Animated.Adaptable<number>, upperBound: Animated.Adaptable<number>) => Animated.Node<number>;
```

Clamps a node with a lower and upper bound.

```tsx
clamp(new Value(-1), 0, 100); // 0
clamp(new Value(1), 0, 100); // 1
clamp(new Value(101), 0, 100); // 100
```

---

##  `between()`

```tsx
const between: (value: Animated.Node<number>, lowerBound: Animated.Adaptable<number>, upperBound: Animated.Adaptable<number>, inclusive?: boolean) => Animated.Node<0 | 1>;
```

Returns true if `node` is within `lowerBound` and `upperBound`.

---

## `approximates()`

```tsx
const approximates: (a: Animated.Adaptable<number>, b: Animated.Adaptable<number>, precision?: Animated.Adaptable<number>) => Animated.Node<0 | 1>;
```

Returns 1 if the difference between the two values is less than precision.
Otherwise returns 0.
Default value for the precision is 0.001.

---

## `atan2()`

```tsx
const atan2: (y: Animated.Adaptable<number>, x: Animated.Adaptable<number>) => Animated.Node<number>;
```

Returns the angle in the plane (in radians) between the positive x-axis and the ray from (0,0) to the point (x,y), `atan2(y,x)`.

---

## `round()`

```tsx
const round = (value: Animated.Adaptable<number>, precision: Animated.Adaptable<number> = 0)  => Animated.Node<number>;
```

Computes animation node rounded to `precision`.

---

## `cubicBezier()`

```tsx
const cubicBezier: (t: Animated.Adaptable<number>, p0: Animated.Adaptable<number>, p1: Animated.Adaptable<number>, p2: Animated.Adaptable<number>, p3: Animated.Adaptable<number>) => Animated.Node<number>;
```

Returns the coordinate of a cubic bezier curve.
`t` is the length of the curve from 0 to 1. `cubicBezier(0, p0, p1, p2, p3)` equals `p0` and `cubicBezier(1, p0, p1, p2, p3)` equals `p3`.
`p0` and `p3` are respectively the starting and ending point of the curve.
`p1` and `p2` are the control points.
